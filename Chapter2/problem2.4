I:Partition a list so all values less than x come before the nodes greater or equal to x.

D:Create an algorithm partitions the list so that nodes with values less than x come before the node x and any of the values 
greater than or equal to x go after the node x.

E: Duke's 7 steps
	Step 1: 
		list = {9,4,5,3,1}, x = 4, return the list as {1,3,4,5,9}
		
	Step 2:
		Traverse the list and compare each value to x, if it's less than x then move that node to the beginning of the list.
	Step 3:
		Traverse the list (looping),  compare each value to x (condition), create extra nodes (data structures).
	Step 4: 
		Assume input is {5,4,2,3,7} and x = 3, create head and tail, while(node is not null), if the value of the node is less than x
		move that node to the head of the list, else move that node to the end of the list. So the values would be {2,3,7,5,4}
	Step 5:
    		LinkedlistNode partition(LinkedlistNode node, int x) {
       		LinkedListNode head node;
        	LinkedListNode tail= node;

        	while (node != null) {
            		LinkedListNode next = node.next;
             		if (node.data < x) {
                		node.next= head;
                		head= node;
                	} else {

                		tail.next= node;
                		tail= node;
                	}
            		node= next;
            	}
        	tail.next= null;
        	return head;
        }
A:
	Step 6:
		Assume input is {a,c,h,b,d} with x = d
		Some changes had to be made to the code for it to accept characters as inputs
		The output was {b,c,a,d,h} which was the expected result.
	Step 7:
		Input {Node a, 1, 5, 8}
		The code broke because it cannot take an object as an input.

L: This code is useful in niche cases, it's better to use trees for this kind of task so I wouldn't use it often.
   remove(int index) method or remove(Object o) method from the java linked list.
